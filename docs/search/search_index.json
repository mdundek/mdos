{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the MDos platform MDos is a Kubernetes based application runtime platform, it's aim is to greatly simplify the process of creating, building and deploying applications on a Kubernetes cluster without compromising on security and efficiency Warning MDos is in beta stage at the moment, it is under developement and should not be used in production yet. Before investing more sweat and tears into this, I want to make sure that there is interest from the comunity first. Please test it, provide some feedback, or even better, join the party in developing it further. In a Nutshell Build & deploy your applications on Kubernetes No Kubernetes skills needed to perform complex workflows Hassle free secure multi-tenant cluster usage and isolation Greatly simplifies complex Kubernetes application deployment patterns Provides tools to deal with hard to solve storage related challanges Protect your applications by delegating authentication to MDos using Oauth2 & OIDC Hassle free TLS certificate management Why would you want to use it? Let's face it, Kubernetes is great, most probably one of the best Container runtime platforms ever build with almost endless capabilities. It is no surprising that 70% of all companies use Kubernetes in production somewhere in their public / private cloud environement. That said, it's complexity is often a deterant, and leads to badly designed deployment scenarios, regularly exposing security threaths as well as miss-usage of certain cluster based capabilities, leading to under-utilization of it's capabilities. Companies often end up provisioning multiple Kubernetes clusters to manage multi-tenant scenarios because properly segregating users and projects in a secure way on a single cluster can be complicated to achieve and maintain. Other pain points faced by non kubernetes experts are plentyfull: How do you provision your static application volume content to your Pods? How do you secure your applications on the network level? How do you implement SSO and authentication / authorization mechanisms on your applications? My application does not deploy on Kubernetes, I have no idea why that is and how to fix it? The list goes on and on... After having worked on Kubernetes for several years now and managed teams of developers and architects that had to develop and maintain Kubernetes instances, it became clear for me that something had to change. Companies hire developers to build applications that will run on Kubernetes, but in order to develop applications for Kubernetes, you need to have some solid experience in the domain, making you a rather experienced cloud developer with a undeniable high price tag. Unexperienced developers tend to loose alot of time on understanding Kubernetes in the first place, even more time in learning how to use it properly, leading to very expensive developement cycles to get basic applications up and running. Financially, this does not make much sense. If every company had to only hire experienced kubernetes developers to get anything done with it, project costs would rapidly spiral out of control, without mentioning the fact that there are not that many skilled kubernetes experts available in the first place. MDos is an attempt to solve some of those complexity issues for developers and companies, letting them focus on developing applications and not about how to get them running securely on Kubernetes. Features Those can be split into 5 families: Application specific resource configurations Deploy and debug your applications Advanced volume and storage workflows Multi-tenant based segregation OIDC / OAuth2 authentication & Application RBAC Cert-Manager for TLS certificate issuer and secret management 1. Application specific resource configurations Using the MDos CLI and a unified mdos.yaml application descriptor file, you can build complex Kubernetes deployment senarios without any knowledge of Kubernetes resource definition types such as Deployments , StatefulSets , Pods , Services , PV & PVCs , VirtualServices , Secrets , ConfigMaps , NetworkPolicies ... (just to name a few) Therefore, build your applications using higher level artefacts that will translate to lower level Kubernetes resource definitions based on Kubernetes best practices. Scaffold a new application workspace Scaffold a application component inside your mdos application Add config files & environement variables to your application components Add secret (sensitive) files and environement variables to your application components Expose your application components to other resources within the cluster Configure hostname based ingress rules to allow access to your application components from outside of the cluster Mount various volume types to your application components ... 2. Deploy and debug your applications One mdos CLI command to deploy your applications and sync static volumes with your pods Get real-time detailed feedback on your deployments, providing valuable feedback on what might go wrong in order to fix it Get all application component logs, including init container logs in case of a failed deployment for instant debugging Aggregate all application & platform logs in Loki, accessible through a dedicated API (TODO) 3. Advanced volume and storage workflows Synchronize / provision static local data with your application component volumes before they start in Kubernetes Provision shared filesystem volumes for your application components (TODO) 4. Multi-tenant based segregation A tenant will get a Kubernetes namespace as well as a dedicated Keycloak client (for user management) You can create users on the platform and link them to one or more tenants Manage user permissions (RBAC) specifcally for each tenant namespace / keycloak client Kubernetes namespaces let you take advantage of network and resource segregation mechanisms for each tenant 5. OIDC / OAuth2 authentication & Application RBAC Provision OIDC / OAuth2 based Authentication providers to your cluster ready to use Link OIDC / OAuth2 provisioned providers to your application components to protect those resources (no app changes needed) Assign roles to your users specifically on each tenant / keycloak client, allowing you to implement your ACL logic without having to deal with authentication at all 6. Cert-Manager for TLS certificate issuer and secret management Register Cert-Manager Issuers onto your cluster or namespace Generate and manage certificates / secrets from your Issuers","title":"Home"},{"location":"#welcome-to-the-mdos-platform","text":"MDos is a Kubernetes based application runtime platform, it's aim is to greatly simplify the process of creating, building and deploying applications on a Kubernetes cluster without compromising on security and efficiency Warning MDos is in beta stage at the moment, it is under developement and should not be used in production yet. Before investing more sweat and tears into this, I want to make sure that there is interest from the comunity first. Please test it, provide some feedback, or even better, join the party in developing it further.","title":"Welcome to the MDos platform"},{"location":"#in-a-nutshell","text":"Build & deploy your applications on Kubernetes No Kubernetes skills needed to perform complex workflows Hassle free secure multi-tenant cluster usage and isolation Greatly simplifies complex Kubernetes application deployment patterns Provides tools to deal with hard to solve storage related challanges Protect your applications by delegating authentication to MDos using Oauth2 & OIDC Hassle free TLS certificate management","title":"In a Nutshell"},{"location":"#why-would-you-want-to-use-it","text":"Let's face it, Kubernetes is great, most probably one of the best Container runtime platforms ever build with almost endless capabilities. It is no surprising that 70% of all companies use Kubernetes in production somewhere in their public / private cloud environement. That said, it's complexity is often a deterant, and leads to badly designed deployment scenarios, regularly exposing security threaths as well as miss-usage of certain cluster based capabilities, leading to under-utilization of it's capabilities. Companies often end up provisioning multiple Kubernetes clusters to manage multi-tenant scenarios because properly segregating users and projects in a secure way on a single cluster can be complicated to achieve and maintain. Other pain points faced by non kubernetes experts are plentyfull: How do you provision your static application volume content to your Pods? How do you secure your applications on the network level? How do you implement SSO and authentication / authorization mechanisms on your applications? My application does not deploy on Kubernetes, I have no idea why that is and how to fix it? The list goes on and on... After having worked on Kubernetes for several years now and managed teams of developers and architects that had to develop and maintain Kubernetes instances, it became clear for me that something had to change. Companies hire developers to build applications that will run on Kubernetes, but in order to develop applications for Kubernetes, you need to have some solid experience in the domain, making you a rather experienced cloud developer with a undeniable high price tag. Unexperienced developers tend to loose alot of time on understanding Kubernetes in the first place, even more time in learning how to use it properly, leading to very expensive developement cycles to get basic applications up and running. Financially, this does not make much sense. If every company had to only hire experienced kubernetes developers to get anything done with it, project costs would rapidly spiral out of control, without mentioning the fact that there are not that many skilled kubernetes experts available in the first place. MDos is an attempt to solve some of those complexity issues for developers and companies, letting them focus on developing applications and not about how to get them running securely on Kubernetes.","title":"Why would you want to use it?"},{"location":"#features","text":"Those can be split into 5 families: Application specific resource configurations Deploy and debug your applications Advanced volume and storage workflows Multi-tenant based segregation OIDC / OAuth2 authentication & Application RBAC Cert-Manager for TLS certificate issuer and secret management","title":"Features"},{"location":"#1-application-specific-resource-configurations","text":"Using the MDos CLI and a unified mdos.yaml application descriptor file, you can build complex Kubernetes deployment senarios without any knowledge of Kubernetes resource definition types such as Deployments , StatefulSets , Pods , Services , PV & PVCs , VirtualServices , Secrets , ConfigMaps , NetworkPolicies ... (just to name a few) Therefore, build your applications using higher level artefacts that will translate to lower level Kubernetes resource definitions based on Kubernetes best practices. Scaffold a new application workspace Scaffold a application component inside your mdos application Add config files & environement variables to your application components Add secret (sensitive) files and environement variables to your application components Expose your application components to other resources within the cluster Configure hostname based ingress rules to allow access to your application components from outside of the cluster Mount various volume types to your application components ...","title":"1. Application specific resource configurations"},{"location":"#2-deploy-and-debug-your-applications","text":"One mdos CLI command to deploy your applications and sync static volumes with your pods Get real-time detailed feedback on your deployments, providing valuable feedback on what might go wrong in order to fix it Get all application component logs, including init container logs in case of a failed deployment for instant debugging Aggregate all application & platform logs in Loki, accessible through a dedicated API (TODO)","title":"2. Deploy and debug your applications"},{"location":"#3-advanced-volume-and-storage-workflows","text":"Synchronize / provision static local data with your application component volumes before they start in Kubernetes Provision shared filesystem volumes for your application components (TODO)","title":"3. Advanced volume and storage workflows"},{"location":"#4-multi-tenant-based-segregation","text":"A tenant will get a Kubernetes namespace as well as a dedicated Keycloak client (for user management) You can create users on the platform and link them to one or more tenants Manage user permissions (RBAC) specifcally for each tenant namespace / keycloak client Kubernetes namespaces let you take advantage of network and resource segregation mechanisms for each tenant","title":"4. Multi-tenant based segregation"},{"location":"#5-oidc-oauth2-authentication-application-rbac","text":"Provision OIDC / OAuth2 based Authentication providers to your cluster ready to use Link OIDC / OAuth2 provisioned providers to your application components to protect those resources (no app changes needed) Assign roles to your users specifically on each tenant / keycloak client, allowing you to implement your ACL logic without having to deal with authentication at all","title":"5. OIDC / OAuth2 authentication &amp; Application RBAC"},{"location":"#6-cert-manager-for-tls-certificate-issuer-and-secret-management","text":"Register Cert-Manager Issuers onto your cluster or namespace Generate and manage certificates / secrets from your Issuers","title":"6. Cert-Manager for TLS certificate issuer and secret management"},{"location":"advanced-resources/","text":"Advanced Resources Manage Namespaces, Users, Roles and Permissions Securing applications using OIDC providers Managing your Issuers & TLS Certificates using Cert-Manager Managing your Domain specific Ingress-Gateways","title":"Advanced Resources"},{"location":"advanced-resources/#advanced-resources","text":"","title":"Advanced Resources"},{"location":"advanced-resources/#manage-namespaces-users-roles-and-permissions","text":"","title":"Manage Namespaces, Users, Roles and Permissions"},{"location":"advanced-resources/#securing-applications-using-oidc-providers","text":"","title":"Securing applications using OIDC providers"},{"location":"advanced-resources/#managing-your-issuers-tls-certificates-using-cert-manager","text":"","title":"Managing your Issuers &amp; TLS Certificates using Cert-Manager"},{"location":"advanced-resources/#managing-your-domain-specific-ingress-gateways","text":"","title":"Managing your Domain specific Ingress-Gateways"},{"location":"getting-started/","text":"Getting Started We will build a similar hello world example application now, but to keep thinks simple, we will not deploy a backend component along with the frontend component, and not work with volumes yet. Those will be subjects for later on. First, we need to configure our MDos CLI so that it knows how to talk to our MDos API server. MDos \"Hello World\" example Configure your CLI to point to a MDos platform API host Before we can start using the mdos CLI, we need to tell it what MDos API server to talk to. Warning If you installed the platform using a self-signed certificate without any valid domain names configured, then you will have to ensure that all required platform hostnames are configured on your local machine hosts file before you prosceed. In Linux and Mac OSX, your can configure those in your /etc/hosts file. In Windows, this file is located under c:\\Windows\\System32\\Drivers\\etc\\hosts . For more information, please refer to the chapter Special notes about self-signed certificates without a resolvable DNS name To configure the target MDos platform API server endpoint with your CLI, use the following command: mdos configure api-endpoint https://mdos-api.mydomain.com Replace mydomain.com with your actual domain name used during the platform installation procedure. You are now ready to start using the platform. Create a tenant namespace In Kubernetes, namespaces are used to group assets together so that they can be properly administered & run in their own scoped context. In MDos, we assign a dedicated namespace to each tenant on the platform. Applications belong to a tenant namespace, without the namespace we can not deploy our application. To create a new tenant namespace called a-team , run the following command: mdos namespace create WARN : Your current token has expired or is invalid. You need to re-authenticate ? Please enter your username: admin-username ? Please enter your password: [hidden] ? Enter a namespace name to create: a-team Creating namespace... done Note If this is the first time you interact with the platform (or if your JWT token has expired like in the example above), you will be asked to authenticate yourself first. In our case, we did not add any platform users yet, so we will simply use the admin user account that was used during the platform installation procedure (in this example, the admin username is called admin-username ). If you already have your own user account on the platform, and you have sufficient permissions to create new tenant namespaces and deploy applications, then please go ahead and use this one instead. So what happened on the platform side when you create a namespace using the MDos CLI? Here are some high level details: Create a new Client in Keycloak, required to manage users that will interact with this namespace Create available default roles for this Keycloak client / namespace ( admin , k8s-write , k8s-read , ftp-write , registry-pull , registry-push ) Create namespace in Kubernetes Create namespace roles so that we can apply RBAC permissions to users Configure service account / credentials in Keycloak for ftpd and registry access for this namespace Note Details about these concepts are out of scope in this chapter Create a new application Let's create a new application project using the mdos CLI command: mdos generate application ? Enter a application name: hello-world ? Enter a tenant name that this application belongs to: a-team This will create a new folder with the mdos.yaml configuration file in it. We are now ready to create application components. Create a new application component Inside your application project folder, run the following command: cd hello-world mdos generate component ? Enter a application component name: hello-world-server The CLI will ask you a couple of things about some base configuration parameters. This will create a new component folder with an empty Dockerfile for you to use, as well as update the mdos.yaml file referencing the component as part of the overall application project along with it's configuration parameters. You can now go ahead and implement your hello-world-server application component. Let's do just that. We will create a basic NodeJS HTTP server for this demonstration that will return \"hello world\" when invoked. Create a new file: hello-world/hello-world-server/index.js index.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const http = require ( 'http' ); // Loads the http module http . createServer (( request , response ) => { // 1. Tell the browser everything is OK (Status code 200), and the data is in plain text response . writeHead ( 200 , { 'Content-Type' : 'text/plain' }); // 2. Write the announced text to the body of the page response . write ( 'Hello, World!\\n' ); // 3. Tell the server that all of the response headers and body have been sent response . end (); }). listen ( 8080 ); // 4. Tells the server what port to be on Last but not least, we need to populate our component Dockerfile so that we can build our container image during deployments. Open the Dockerfile that is inside the hello-world-server folder and set it's content to the following: Dockerfile 1 2 3 4 5 6 7 8 9 10 FROM node:16 # Create app directory WORKDIR /usr/src/app # Bundle app source COPY ./server.js . EXPOSE 8080 CMD [ \"node\" , \"server.js\" ] Ok, we have an application ready to use now. Next, we need to tell our mdos application that we want to expose port 8080 , and set up an ingress config to expose it outside of the cluster using the hostname hello-world.mydomain.com . Note As of now, MDos uses the platform wildcard domain name that was configured during the installation of the platform in order to expose any application you deploy on it. You can of course add other domain names for your various applications if you like, to do so you will have to create a new ingress-gateway configuration in your namespace, but this is out of scope in this example. Let's start with exposing port 8080 for our application component, which can be done with a kubernetes service . Move into the hello-world-server component folder and execute the following command: mdos generate service ? Enter a name for the service to add a port to: http ? Specify a port number on which your application needs to be accessible on: 8080 And finally, the ingress so that we have a hostname configured to access this application: mdos generate ingress ? Enter a name for the ingress: http-ingress ? What hostname do you want to use to access your component port: hello-world.mydomain.com ? Do you want to match a subpath for this host? No ? What target port should this traffic be redirected to? 8080 ? What type of traffic will this ingress handle? http Note Again, replace mydomain.com with whatever domain you configured during the platform installation. That's it, this is what your project file structure should look like now: Project structure hello-world \u251c\u2500\u2500 hello-world-server \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u2514\u2500\u2500 server.js \u251c\u2500\u2500 mdos.yaml \u2514\u2500\u2500 volumes \u2514\u2500\u2500 README.md Let's have a look at the generated code in the mdos.yaml file: mdos.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 schemaVersion : v1 tenantName : a-team appName : hello-world uuid : mvx10-x2wip components : - name : hello-world-server image : hello-world uuid : qx8su-jwqvi tag : 0.0.1 services : - name : http ports : - port : 8080 ingress : - name : http-ingress matchHost : hello-world.mydomain.com targetPort : 8080 trafficType : http Note All application configuration features will live inside this yaml file, even for the most advanced use-cases and config needs, everything will be here. No need to get dirty with low level kubernetes assets to make it all happen, the platform will translate it all into the proper artefacts for you. To learn more about everything that you can configure for your deployments in this yaml file, please check out the MDos application reference documentation Deploy your hello-world application on the cluster Note Since this is a basic example, we will skip user management, authentication or any other advanced topics for now. Since we authenticated with the MDos admin user account, we can deploy onto this namespace without creating / assigning users & permissions for this namespace. Move into the hello-world application and execute the command: mdos application deploy Synching volumes... done To push your images to the mdos registry, you need to provide your mdos username and password first ? Username: admin-username ? Password: ******** Building application image registry.mydomain.com/a-team/hello-world:0.0.1... done Pushing application image registry.mydomain.com/a-team/hello-world:0.0.1... done Deploying application... scheduled Pod: hello-world-server Phase: Running Container: hello-world-hello-world-server State: running Details: n/a SUCCESS : Application deployed That's it, your application should now be accessible on the following domain: https://hello-world.mydomain.com OIDC Providers for authentication Create a Keycloak based OIDC Provider Note The platform provided Keycloak instance is used for Keycloak based providers Create a Google based OIDC Provider Warning In construction Kubectl OIDC setup for RBAC","title":"Getting Started"},{"location":"getting-started/#getting-started","text":"We will build a similar hello world example application now, but to keep thinks simple, we will not deploy a backend component along with the frontend component, and not work with volumes yet. Those will be subjects for later on. First, we need to configure our MDos CLI so that it knows how to talk to our MDos API server.","title":"Getting Started"},{"location":"getting-started/#mdos-hello-world-example","text":"","title":"MDos \"Hello World\" example"},{"location":"getting-started/#configure-your-cli-to-point-to-a-mdos-platform-api-host","text":"Before we can start using the mdos CLI, we need to tell it what MDos API server to talk to. Warning If you installed the platform using a self-signed certificate without any valid domain names configured, then you will have to ensure that all required platform hostnames are configured on your local machine hosts file before you prosceed. In Linux and Mac OSX, your can configure those in your /etc/hosts file. In Windows, this file is located under c:\\Windows\\System32\\Drivers\\etc\\hosts . For more information, please refer to the chapter Special notes about self-signed certificates without a resolvable DNS name To configure the target MDos platform API server endpoint with your CLI, use the following command: mdos configure api-endpoint https://mdos-api.mydomain.com Replace mydomain.com with your actual domain name used during the platform installation procedure. You are now ready to start using the platform.","title":"Configure your CLI to point to a MDos platform API host"},{"location":"getting-started/#create-a-tenant-namespace","text":"In Kubernetes, namespaces are used to group assets together so that they can be properly administered & run in their own scoped context. In MDos, we assign a dedicated namespace to each tenant on the platform. Applications belong to a tenant namespace, without the namespace we can not deploy our application. To create a new tenant namespace called a-team , run the following command: mdos namespace create WARN : Your current token has expired or is invalid. You need to re-authenticate ? Please enter your username: admin-username ? Please enter your password: [hidden] ? Enter a namespace name to create: a-team Creating namespace... done Note If this is the first time you interact with the platform (or if your JWT token has expired like in the example above), you will be asked to authenticate yourself first. In our case, we did not add any platform users yet, so we will simply use the admin user account that was used during the platform installation procedure (in this example, the admin username is called admin-username ). If you already have your own user account on the platform, and you have sufficient permissions to create new tenant namespaces and deploy applications, then please go ahead and use this one instead. So what happened on the platform side when you create a namespace using the MDos CLI? Here are some high level details: Create a new Client in Keycloak, required to manage users that will interact with this namespace Create available default roles for this Keycloak client / namespace ( admin , k8s-write , k8s-read , ftp-write , registry-pull , registry-push ) Create namespace in Kubernetes Create namespace roles so that we can apply RBAC permissions to users Configure service account / credentials in Keycloak for ftpd and registry access for this namespace Note Details about these concepts are out of scope in this chapter","title":"Create a tenant namespace"},{"location":"getting-started/#create-a-new-application","text":"Let's create a new application project using the mdos CLI command: mdos generate application ? Enter a application name: hello-world ? Enter a tenant name that this application belongs to: a-team This will create a new folder with the mdos.yaml configuration file in it. We are now ready to create application components.","title":"Create a new application"},{"location":"getting-started/#create-a-new-application-component","text":"Inside your application project folder, run the following command: cd hello-world mdos generate component ? Enter a application component name: hello-world-server The CLI will ask you a couple of things about some base configuration parameters. This will create a new component folder with an empty Dockerfile for you to use, as well as update the mdos.yaml file referencing the component as part of the overall application project along with it's configuration parameters. You can now go ahead and implement your hello-world-server application component. Let's do just that. We will create a basic NodeJS HTTP server for this demonstration that will return \"hello world\" when invoked. Create a new file: hello-world/hello-world-server/index.js index.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 const http = require ( 'http' ); // Loads the http module http . createServer (( request , response ) => { // 1. Tell the browser everything is OK (Status code 200), and the data is in plain text response . writeHead ( 200 , { 'Content-Type' : 'text/plain' }); // 2. Write the announced text to the body of the page response . write ( 'Hello, World!\\n' ); // 3. Tell the server that all of the response headers and body have been sent response . end (); }). listen ( 8080 ); // 4. Tells the server what port to be on Last but not least, we need to populate our component Dockerfile so that we can build our container image during deployments. Open the Dockerfile that is inside the hello-world-server folder and set it's content to the following: Dockerfile 1 2 3 4 5 6 7 8 9 10 FROM node:16 # Create app directory WORKDIR /usr/src/app # Bundle app source COPY ./server.js . EXPOSE 8080 CMD [ \"node\" , \"server.js\" ] Ok, we have an application ready to use now. Next, we need to tell our mdos application that we want to expose port 8080 , and set up an ingress config to expose it outside of the cluster using the hostname hello-world.mydomain.com . Note As of now, MDos uses the platform wildcard domain name that was configured during the installation of the platform in order to expose any application you deploy on it. You can of course add other domain names for your various applications if you like, to do so you will have to create a new ingress-gateway configuration in your namespace, but this is out of scope in this example. Let's start with exposing port 8080 for our application component, which can be done with a kubernetes service . Move into the hello-world-server component folder and execute the following command: mdos generate service ? Enter a name for the service to add a port to: http ? Specify a port number on which your application needs to be accessible on: 8080 And finally, the ingress so that we have a hostname configured to access this application: mdos generate ingress ? Enter a name for the ingress: http-ingress ? What hostname do you want to use to access your component port: hello-world.mydomain.com ? Do you want to match a subpath for this host? No ? What target port should this traffic be redirected to? 8080 ? What type of traffic will this ingress handle? http Note Again, replace mydomain.com with whatever domain you configured during the platform installation. That's it, this is what your project file structure should look like now: Project structure hello-world \u251c\u2500\u2500 hello-world-server \u2502 \u251c\u2500\u2500 Dockerfile \u2502 \u2514\u2500\u2500 server.js \u251c\u2500\u2500 mdos.yaml \u2514\u2500\u2500 volumes \u2514\u2500\u2500 README.md Let's have a look at the generated code in the mdos.yaml file: mdos.yaml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 schemaVersion : v1 tenantName : a-team appName : hello-world uuid : mvx10-x2wip components : - name : hello-world-server image : hello-world uuid : qx8su-jwqvi tag : 0.0.1 services : - name : http ports : - port : 8080 ingress : - name : http-ingress matchHost : hello-world.mydomain.com targetPort : 8080 trafficType : http Note All application configuration features will live inside this yaml file, even for the most advanced use-cases and config needs, everything will be here. No need to get dirty with low level kubernetes assets to make it all happen, the platform will translate it all into the proper artefacts for you. To learn more about everything that you can configure for your deployments in this yaml file, please check out the MDos application reference documentation","title":"Create a new application component"},{"location":"getting-started/#deploy-your-hello-world-application-on-the-cluster","text":"Note Since this is a basic example, we will skip user management, authentication or any other advanced topics for now. Since we authenticated with the MDos admin user account, we can deploy onto this namespace without creating / assigning users & permissions for this namespace. Move into the hello-world application and execute the command: mdos application deploy Synching volumes... done To push your images to the mdos registry, you need to provide your mdos username and password first ? Username: admin-username ? Password: ******** Building application image registry.mydomain.com/a-team/hello-world:0.0.1... done Pushing application image registry.mydomain.com/a-team/hello-world:0.0.1... done Deploying application... scheduled Pod: hello-world-server Phase: Running Container: hello-world-hello-world-server State: running Details: n/a SUCCESS : Application deployed That's it, your application should now be accessible on the following domain: https://hello-world.mydomain.com","title":"Deploy your hello-world application on the cluster"},{"location":"getting-started/#oidc-providers-for-authentication","text":"","title":"OIDC Providers for authentication"},{"location":"getting-started/#create-a-keycloak-based-oidc-provider","text":"Note The platform provided Keycloak instance is used for Keycloak based providers","title":"Create a Keycloak based OIDC Provider"},{"location":"getting-started/#create-a-google-based-oidc-provider","text":"Warning In construction","title":"Create a Google based OIDC Provider"},{"location":"getting-started/#kubectl-oidc-setup-for-rbac","text":"","title":"Kubectl OIDC setup for RBAC"},{"location":"installation/","text":"Installation & setup Install the MDos (server) platform Info At the moment, only Ubuntu >= 20.04 is supported for the MDos platform itself. Debian and Alpine are planned next. The MDos CLI is available for Max, linux and Windows First, clone this repo on your target machine: git clone https://github.com/mdundek/mdos.git Before you start The installation will require that you configure a valid domain name and a certificate for the mdos base platform (for developement purposes you can choose to work with a self-signed certificate). If you plan on using cert-manager to manage your certificate, then you will have to prepare a Issuer yaml file upfront before you go ahead and start the installation script (see bellow for an example using a CloudFlare issuer). Master node & MDos control plane Install the platform by calling the following script as root: sudo ./mdos-setup/install.sh During the installation procedure, you will be asked to provide a few details. You will have to start by providing your MDos platform host IP address. Then select if you would like to automatically configure the host firewall in order to allow the required traffic policies for MDos. Administrator credentials The platform will create a overall admin account on the platform. Please provide the admin username, email and password first: Domain & certificate setup Some of the components such as the registry auth server require a TLS certificate to function. The installation script will give you multiple choices here: You have a valid certificate at hand that you would like to use You want to set up cert-manager to generate and manage your certificate (Let's Encrypt, CloudFlare, Vault, AWS, Google...) You have no certificate and would like to create a self-signed certificate (only suited for developement purposes) Warning For developement purposes, you can have the platform generate a self signed certificate for you, but SSO / OIDC functionality will not work with a self-signed certificate. For production, you will have to use a fully valid certificate in order to use all of MDos features. Cert-manager example Self-signed certificate example Here we are using cert-manager to generate and manage the certificate for you Example Issuer must use the name mdos-issuer , the rest is up to you. Here is an example Issuer yaml file that uses CloudFlare as the DNS registrar & Let's Encrypt to generate and sign your certificate: issuer.yaml apiVersion : v1 kind : Secret metadata : name : cloudflare-api-key-secret type : Opaque stringData : api-key : <YOUR CLOUDFLARE API KEY> --- apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : mdos-issuer spec : acme : email : <YOUR LETS-ENCRYPT EMAIL ADDRESS> server : https://acme-v02.api.letsencrypt.org/directory privateKeySecretRef : name : letsencrypt-prod solvers : - dns01 : cloudflare : email : <YOUR CLOUDFLARE EMAIL ADDRESS> apiKeySecretRef : name : cloudflare-api-key-secret key : api-key Other examples for various providers can be found at: https://cert-manager.io/docs/configuration/acme/dns01/#supported-dns01-providers This example is based on the 3rd option, a self signed certificate. If you want to use cert-manager instead (good option for production environement), you will be asked to enter the path to your cert-manager Issuer Yaml file to use in order to issue your certificate. Kubernetes workload storage directory path When you deploy applications onto your Kubernetes cluster, chances are that your applications will require to use permanent / persisted storage. Containers by default do not persist data beyond a container restart, You will therefore have to persist your container data on Kubernetes managed storage. MDos uses Longhorn from Rancher as a storage class. Longhorn will store your container volume data in a dedicated directory on each Cluster Node. This is your chance to customize this directory path in case you want to store this data on an external hard drive that you mounted onto your host system. Please note that you need to ensure that you have enougth storage capacity on this directory path, it is recommended to mount a separate dedicated disk for this purpose: Note Longhorn is a block storage provider, it replicates your data over multiple disks / partitions. Longhorn does work with only one disk, which is it's default setup configuration, but it is highly recommended that you configure at least 2, idealy 3 disks for optimal data redundancy. To configure those disk, on the same machine or on different machines, use the longhorn UI accessible under the URL https://longhorn.<ROOT-DOMAIN> Private registry max size MDos comes with a private registry where you can store your images on. The Kubernetes cluster is configured to use this registry if that's what you want to do in order to keep your images inhouse. This is also a must if you intend to run the platform in offline mode. The registry runs in Kubernetes, it therefore needs to allocate some storage to it so that it can persist it's data on your disk. Here you need to specify how much space you wish to allocate to this registry (in Gigabytes). Note Please note that this storage capacity will be located on your main Kubernetes storage path specified above FTP sync server for Kubernetes POD data provisionning When running applications in kubernetes using CSI storage plugins, you usually end up with a blank volume once your pod starts for the first time. This is usually a pain point for many developers who end up using hostPath mount points instead. This is an antipatern and does not go well with multi-node cluster environements where you can not easiely predict where your pod is going to start. MDos provides you with a means to initialize your application pods with data pre-alocated to it's volumes. This can be very usefull for usecases such as (but not only): Provision a volume with a already pre-established database schema and data set for initialization purposes (or any other type of initialization data sets) Provision static data such as websites or for anything else for that matter... This is achieved by providing a centralized storage space on the mdos platform where a FTP server will allow you to (using the mdos CLI) mirror your application volume data from your local machine to the centralized FTP storage device where Kubernetes will then mirror those data volumes onto your POD volumes using initContainers and the FTP protocol. Here you are being asked to provide a directory path to where this centralized data will be hosted. Again, this is your chance to customize this directory path in case you want to store this data on an external hard drive that you mounted onto your host system: Configure Keycloak and set up the master token After a few minutes (can take up to 10 minutes, depending on your internet speed), you will be asked to set up Keycloak and provide a secret token to the installation script. This token is necessary so that mdos can administer everything it needs on Keycloak. The script provides you with detailed instructions on how to do so, simply follow them and enter the secret token from the Keycloak website. To finalyze the setup, do the following: 1. Open a browser and go to: https://keycloak.mydomain.com/admin/master/console/#/realms/master/clients 2. From the 'Clients' section, click on the client 'master-realm' 3. Change 'Access Type' value to 'confidential' 4. Enable the boolean value 'Service Accounts Enabled' 5. Set 'Valid Redirect URIs' value to '*' 6. Save those changes (button at the bottom of the page) 7. In tab 'Roles', Click on button 'edit' for role 'magage realm'. Enable 'Composite roles' and add 'admin' realm to associated roles 8. Go to the 'Service Account Roles' tab and add the role 'admin' to the 'Assigned Roles' box 9. Click on tab 'Credentials' 10. When ready, copy and paste the 'Secret' value into this terminal, then press enter: SECRET: cXXyx8EtGGL8BgCC9zVYQidKYuctzuXA That's it, once the installation script is finished you are ready to use the platform. Worker nodes To add a new worker node to your mdos cluster deployment, clone the mdso repo on the new node machine and execute the following script as root: sudo ./mdos-setup/install-worker.sh Warning Under construction Install the MDos CLI Linux & Mac OSX The standalone install is a simple tarball with a binary. It contains its own node.js binary and autoupdates. To set up the CLI in /usr/local/lib/mdos and /usr/local/bin/mdos , run the following script. The script requires sudo and isn\u2019t Windows compatible . # Install latest version curl https://raw.githubusercontent.com/mdundek/mdos/main/mdos-cli/infra/install-linux-mac.sh | sudo bash To install a specific version of the CLI, do: # NOTE: the version in this example might be outdated. This example is simply to # showcase how you can install a specific version of the CLI in case your mdos server # installation is on an older version curl https://raw.githubusercontent.com/mdundek/mdos/main/mdos-cli/infra/install-linux-mac.sh | sudo bash -s -- v1.2.0 Windows Warning Under construction Verify Your Installation To verify your CLI installation, use the mdos --version command: mdos --version mdos-cli/0.0.0 linux-x64 node-v18.9.0 Special notes about self-signed certificates without a resolvable DNS name For developement purposes, you can use self-signed certificates without a publicly available DNS name. That said, you will have to configure your hosts file from wherever you wish to use the CLI from so that it can resolve the various hostnames used by the MDos API platform. Note Please replace XXX.XXX.XXX.XXX with the MDos Platform server IP address, and mydomain.com with the actual domain used when you deployed the MDos platform. Linux & Mac OSX Open your /etc/hosts file (root user) and add the following entries to it: XXX.XXX.XXX.XXX registry.mydomain.com registry-auth.mydomain.com mdos-api.mydomain.com mdos-ftp.mydomain.com mdos-ftp-api.mydomain.com longhorn.mydomain.com Note Please replace XXX.XXX.XXX.XXX with the MDos Platform server IP address, and mydomain.com with the actual domain used when you deployed the MDos platform. Windows Open your c:\\Windows\\System32\\Drivers\\etc\\hosts file (root user) and add the following entries to it: XXX.XXX.XXX.XXX registry.mydomain.com XXX.XXX.XXX.XXX registry-auth.mydomain.com XXX.XXX.XXX.XXX mdos-api.mydomain.com XXX.XXX.XXX.XXX mdos-ftp.mydomain.com XXX.XXX.XXX.XXX mdos-ftp-api.mydomain.com XXX.XXX.XXX.XXX longhorn.mydomain.com","title":"Install"},{"location":"installation/#installation-setup","text":"","title":"Installation &amp; setup"},{"location":"installation/#install-the-mdos-server-platform","text":"Info At the moment, only Ubuntu >= 20.04 is supported for the MDos platform itself. Debian and Alpine are planned next. The MDos CLI is available for Max, linux and Windows First, clone this repo on your target machine: git clone https://github.com/mdundek/mdos.git","title":"Install the MDos (server) platform"},{"location":"installation/#before-you-start","text":"The installation will require that you configure a valid domain name and a certificate for the mdos base platform (for developement purposes you can choose to work with a self-signed certificate). If you plan on using cert-manager to manage your certificate, then you will have to prepare a Issuer yaml file upfront before you go ahead and start the installation script (see bellow for an example using a CloudFlare issuer).","title":"Before you start"},{"location":"installation/#master-node-mdos-control-plane","text":"Install the platform by calling the following script as root: sudo ./mdos-setup/install.sh During the installation procedure, you will be asked to provide a few details. You will have to start by providing your MDos platform host IP address. Then select if you would like to automatically configure the host firewall in order to allow the required traffic policies for MDos.","title":"Master node &amp; MDos control plane"},{"location":"installation/#administrator-credentials","text":"The platform will create a overall admin account on the platform. Please provide the admin username, email and password first:","title":" Administrator credentials"},{"location":"installation/#domain-certificate-setup","text":"Some of the components such as the registry auth server require a TLS certificate to function. The installation script will give you multiple choices here: You have a valid certificate at hand that you would like to use You want to set up cert-manager to generate and manage your certificate (Let's Encrypt, CloudFlare, Vault, AWS, Google...) You have no certificate and would like to create a self-signed certificate (only suited for developement purposes) Warning For developement purposes, you can have the platform generate a self signed certificate for you, but SSO / OIDC functionality will not work with a self-signed certificate. For production, you will have to use a fully valid certificate in order to use all of MDos features. Cert-manager example Self-signed certificate example Here we are using cert-manager to generate and manage the certificate for you Example Issuer must use the name mdos-issuer , the rest is up to you. Here is an example Issuer yaml file that uses CloudFlare as the DNS registrar & Let's Encrypt to generate and sign your certificate: issuer.yaml apiVersion : v1 kind : Secret metadata : name : cloudflare-api-key-secret type : Opaque stringData : api-key : <YOUR CLOUDFLARE API KEY> --- apiVersion : cert-manager.io/v1 kind : Issuer metadata : name : mdos-issuer spec : acme : email : <YOUR LETS-ENCRYPT EMAIL ADDRESS> server : https://acme-v02.api.letsencrypt.org/directory privateKeySecretRef : name : letsencrypt-prod solvers : - dns01 : cloudflare : email : <YOUR CLOUDFLARE EMAIL ADDRESS> apiKeySecretRef : name : cloudflare-api-key-secret key : api-key Other examples for various providers can be found at: https://cert-manager.io/docs/configuration/acme/dns01/#supported-dns01-providers This example is based on the 3rd option, a self signed certificate. If you want to use cert-manager instead (good option for production environement), you will be asked to enter the path to your cert-manager Issuer Yaml file to use in order to issue your certificate.","title":" Domain &amp; certificate setup"},{"location":"installation/#kubernetes-workload-storage-directory-path","text":"When you deploy applications onto your Kubernetes cluster, chances are that your applications will require to use permanent / persisted storage. Containers by default do not persist data beyond a container restart, You will therefore have to persist your container data on Kubernetes managed storage. MDos uses Longhorn from Rancher as a storage class. Longhorn will store your container volume data in a dedicated directory on each Cluster Node. This is your chance to customize this directory path in case you want to store this data on an external hard drive that you mounted onto your host system. Please note that you need to ensure that you have enougth storage capacity on this directory path, it is recommended to mount a separate dedicated disk for this purpose: Note Longhorn is a block storage provider, it replicates your data over multiple disks / partitions. Longhorn does work with only one disk, which is it's default setup configuration, but it is highly recommended that you configure at least 2, idealy 3 disks for optimal data redundancy. To configure those disk, on the same machine or on different machines, use the longhorn UI accessible under the URL https://longhorn.<ROOT-DOMAIN>","title":" Kubernetes workload storage directory path"},{"location":"installation/#private-registry-max-size","text":"MDos comes with a private registry where you can store your images on. The Kubernetes cluster is configured to use this registry if that's what you want to do in order to keep your images inhouse. This is also a must if you intend to run the platform in offline mode. The registry runs in Kubernetes, it therefore needs to allocate some storage to it so that it can persist it's data on your disk. Here you need to specify how much space you wish to allocate to this registry (in Gigabytes). Note Please note that this storage capacity will be located on your main Kubernetes storage path specified above","title":" Private registry max size"},{"location":"installation/#ftp-sync-server-for-kubernetes-pod-data-provisionning","text":"When running applications in kubernetes using CSI storage plugins, you usually end up with a blank volume once your pod starts for the first time. This is usually a pain point for many developers who end up using hostPath mount points instead. This is an antipatern and does not go well with multi-node cluster environements where you can not easiely predict where your pod is going to start. MDos provides you with a means to initialize your application pods with data pre-alocated to it's volumes. This can be very usefull for usecases such as (but not only): Provision a volume with a already pre-established database schema and data set for initialization purposes (or any other type of initialization data sets) Provision static data such as websites or for anything else for that matter... This is achieved by providing a centralized storage space on the mdos platform where a FTP server will allow you to (using the mdos CLI) mirror your application volume data from your local machine to the centralized FTP storage device where Kubernetes will then mirror those data volumes onto your POD volumes using initContainers and the FTP protocol. Here you are being asked to provide a directory path to where this centralized data will be hosted. Again, this is your chance to customize this directory path in case you want to store this data on an external hard drive that you mounted onto your host system:","title":" FTP sync server for Kubernetes POD data provisionning"},{"location":"installation/#configure-keycloak-and-set-up-the-master-token","text":"After a few minutes (can take up to 10 minutes, depending on your internet speed), you will be asked to set up Keycloak and provide a secret token to the installation script. This token is necessary so that mdos can administer everything it needs on Keycloak. The script provides you with detailed instructions on how to do so, simply follow them and enter the secret token from the Keycloak website. To finalyze the setup, do the following: 1. Open a browser and go to: https://keycloak.mydomain.com/admin/master/console/#/realms/master/clients 2. From the 'Clients' section, click on the client 'master-realm' 3. Change 'Access Type' value to 'confidential' 4. Enable the boolean value 'Service Accounts Enabled' 5. Set 'Valid Redirect URIs' value to '*' 6. Save those changes (button at the bottom of the page) 7. In tab 'Roles', Click on button 'edit' for role 'magage realm'. Enable 'Composite roles' and add 'admin' realm to associated roles 8. Go to the 'Service Account Roles' tab and add the role 'admin' to the 'Assigned Roles' box 9. Click on tab 'Credentials' 10. When ready, copy and paste the 'Secret' value into this terminal, then press enter: SECRET: cXXyx8EtGGL8BgCC9zVYQidKYuctzuXA That's it, once the installation script is finished you are ready to use the platform.","title":" Configure Keycloak and set up the master token"},{"location":"installation/#worker-nodes","text":"To add a new worker node to your mdos cluster deployment, clone the mdso repo on the new node machine and execute the following script as root: sudo ./mdos-setup/install-worker.sh Warning Under construction","title":"Worker nodes"},{"location":"installation/#install-the-mdos-cli","text":"","title":"Install the MDos CLI"},{"location":"installation/#linux-mac-osx","text":"The standalone install is a simple tarball with a binary. It contains its own node.js binary and autoupdates. To set up the CLI in /usr/local/lib/mdos and /usr/local/bin/mdos , run the following script. The script requires sudo and isn\u2019t Windows compatible . # Install latest version curl https://raw.githubusercontent.com/mdundek/mdos/main/mdos-cli/infra/install-linux-mac.sh | sudo bash To install a specific version of the CLI, do: # NOTE: the version in this example might be outdated. This example is simply to # showcase how you can install a specific version of the CLI in case your mdos server # installation is on an older version curl https://raw.githubusercontent.com/mdundek/mdos/main/mdos-cli/infra/install-linux-mac.sh | sudo bash -s -- v1.2.0","title":"Linux &amp; Mac OSX"},{"location":"installation/#windows","text":"Warning Under construction","title":"Windows"},{"location":"installation/#verify-your-installation","text":"To verify your CLI installation, use the mdos --version command: mdos --version mdos-cli/0.0.0 linux-x64 node-v18.9.0","title":"Verify Your Installation"},{"location":"installation/#special-notes-about-self-signed-certificates-without-a-resolvable-dns-name","text":"For developement purposes, you can use self-signed certificates without a publicly available DNS name. That said, you will have to configure your hosts file from wherever you wish to use the CLI from so that it can resolve the various hostnames used by the MDos API platform. Note Please replace XXX.XXX.XXX.XXX with the MDos Platform server IP address, and mydomain.com with the actual domain used when you deployed the MDos platform.","title":"Special notes about self-signed certificates without a resolvable DNS name"},{"location":"installation/#linux-mac-osx_1","text":"Open your /etc/hosts file (root user) and add the following entries to it: XXX.XXX.XXX.XXX registry.mydomain.com registry-auth.mydomain.com mdos-api.mydomain.com mdos-ftp.mydomain.com mdos-ftp-api.mydomain.com longhorn.mydomain.com Note Please replace XXX.XXX.XXX.XXX with the MDos Platform server IP address, and mydomain.com with the actual domain used when you deployed the MDos platform.","title":" Linux &amp; Mac OSX"},{"location":"installation/#windows_1","text":"Open your c:\\Windows\\System32\\Drivers\\etc\\hosts file (root user) and add the following entries to it: XXX.XXX.XXX.XXX registry.mydomain.com XXX.XXX.XXX.XXX registry-auth.mydomain.com XXX.XXX.XXX.XXX mdos-api.mydomain.com XXX.XXX.XXX.XXX mdos-ftp.mydomain.com XXX.XXX.XXX.XXX mdos-ftp-api.mydomain.com XXX.XXX.XXX.XXX longhorn.mydomain.com","title":" Windows"},{"location":"reference-documentation/","text":"MDos application reference documentation Anatomy of an application Applications are to be seen as a higher level concept, an application in mdos is composed of one or more application components. Application components are your actual project asset placeholders (source code), where one component could be an API backend server for instance, and a second component would hold your front end application and so on. Every application component can have one or more volumes attached to it for storage persistance & data mirroring. This architecture allows you to compose complex applications to suit your needs. A MDos application project layout is composed of one or more folders, each one representing an application component. At the root of the application folder is a mdos.yaml file that holds all runtime configuration parameters for the application and it's components: Project structure my-application/ \u251c\u2500\u2500 backend \u2502 \u2514\u2500\u2500 Dockerfile \u2502 \u2514\u2500\u2500 <your application code files>... \u251c\u2500\u2500 frontend \u2502 \u2514\u2500\u2500 Dockerfile \u2502 \u2514\u2500\u2500 <your application code files>... \u251c\u2500\u2500 volumes \u2502 \u2514\u2500\u2500 static-website \u2502 \u2514\u2500\u2500 index.html \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 mdos.yaml In this example we have an application named my-application , that is composed of two distinct application components: backend & frontend . Each component has it's own Dockerfile. At the application level, there is also a volumes folder where you can store application component volume files to be used within your application, and a mdos.yaml config file that holds all runtime configuration parameters. As an example, here the volumes folder has a subfolder called static-website that is used by the frontend application so serve it's website data. Note Volumes are managed on the application level rather than on the component level in case you wish to share volumes amongst components. Manifest file: mdos.yaml Each application is configured in a YAML file at the root of the application folder. This is the equivalent of your lower level Kubernetes yaml files, but all concatenated into a single, higher level configuration file that greatly abstracts away the complexity of Kubernetes deployment. We will now have a closer look at what you can configure in your application mdos.yaml file. Application Each mdos.yaml file starts with global configuration parameters specific to this application: 1 2 3 4 5 schemaVersion : v1 tenantName : my-team appName : my-application uuid : XA74S-FXCDI components : [ ... ] The tenant-name field maps directly to a kubernetes target namespace . The uuid field is a unique identifier for this application, all dependant resources that this application will create and manage will be tied to this application uuid . CLI command mdos generate application Application component Each application component will translate to a specific deployment on the cluster. Just like an application, a component hase some base values that need to be set: 1 2 3 4 5 6 7 8 9 10 11 12 ... components : - name : comp-1 image : my-comp-1-img-name tag : 1.0.0 uuid : E5PLU-TQMBD ... - name : comp-2 image : my-comp-2-img-name tag : 1.0.0 uuid : HUJKG-GDGHN ... Among those, you will define your component name , image name and image tag to use. CLI command mdos generate component When using the MDos CLI to scaffold your application component, then the CLI will ask you to select amonst multiple network isolation options. You can read more about NetworkPolicy isolation configurations in the section here Registries Registries are where your MDos will push and pull your application images from. Multiple choices are available here. Use the MDos registry MDos comes with a private integrated Docker registry. If no registry parameter is set on your component yaml block, then this private internal registry will be used to push / pull the images from. No extra configuration parameters are required if this is the registry you want to use. 1 2 3 4 5 6 7 ... components : - name : comp-1 ... image : my-comp-1-img-name tag : 1.0.0 ... Use a custom registry If you have your own private registry that you would like to use for your application images, you can do so by specifying a registry value on your component, along with an optionnal imagePullSecrets value that should be used to authenticate with your registry: 1 2 3 4 5 6 7 8 9 10 ... components : - name : comp-1 ... image : my-comp-1-img-name tag : 1.0.0 registry : my.private.registry imagePullSecrets : # Optionnal - name : my-registry-secret ... Note Since you are using your own private registry, it will be up to you to provision your private registry Secret on the target namespace. Use a public registry The third option is to use a public registry, again with an optionnal imagePullSecrets value that should be used to authenticate with the public registry: 1 2 3 4 5 6 7 8 9 components : - name : comp-1 ... image : my-comp-1-img-name tag : 1.0.0 publicRegistry : true imagePullSecrets : # Optionnal - name : my-registry-secret ... Overwrite container default command on start If you wish to overwrite the command used by a container on startup, you can so so like this: 1 2 3 4 5 6 7 8 9 10 ... components : - name : comp-1 ... command : - \"sh\" - \"-c\" - \"mycommand\" workingDir : /from/this/dir # optional ... or along with command aguments: 1 2 3 4 5 6 7 8 ... components : - name : comp-1 ... command : [ \"printenv\" ] commandArgs : [ \"HOSTNAME\" , \"KUBERNETES_PORT\" ] workingDir : /from/this/dir # optional ... Persisted Volumes Standard volumes 1 2 3 4 5 6 7 8 9 ... components : - name : comp-1 ... volumes : - name : database-storage mountPath : /usr/data/db size : 10Gi ... CLI command mdos generate volume Shared volumes mdos shared-volume create 1 2 3 4 5 6 7 8 9 ... components : - name : comp-1 ... volumes : - name : database-storage mountPath : /usr/data/db ref : my-shared-volume # existing secret / configMap name to reference ... CLI command mdos generate volume Pre-populate volumes 1 2 3 4 5 6 7 8 9 10 ... components : - name : comp-1 ... volumes : - name : static-website mountPath : /usr/share/nginx/html syncVolume : true size : 10Gi ... Project structure 1 2 3 4 5 6 ... \u251c\u2500\u2500 volumes \u2502 \u2514\u2500\u2500 static-website \u2502 \u2514\u2500\u2500 index.html \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 mdos.yaml CLI command mdos generate volume HostPath mounts 1 2 3 4 5 6 7 8 9 ... components : - name : comp-1 ... volumes : - name : database-storage mountPath : /usr/data/db hostPath : /path/to/folder/on/node ... CLI command mdos generate volume ReadOnly volumes & files Using Secrets Mount as directory Mount as files 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ... components : - name : comp-1 ... secrets : - name : my-ca type : dir mountPath : /etc/x509/https entries : - key : ca.crt value : |- -----BEGIN CERTIFICATE----- ... -----END CERTIFICATE----- - key : ca.key value : |- -----BEGIN EC PRIVATE KEY----- ... -----END EC PRIVATE KEY----- ... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ... components : - name : comp-1 ... secrets : - name : my-ca type : file mountPath : /etc/x509/https entries : - key : client-ca filename : ca.crt value : |- -----BEGIN CERTIFICATE----- ... -----END CERTIFICATE----- - key : client-key filename : ca.key value : |- -----BEGIN EC PRIVATE KEY----- ... -----END EC PRIVATE KEY----- ... CLI command mdos generate secret Using ConfigMaps Mount as directory Mount as files 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ... components : - name : comp-1 ... configs : - name : my-ca type : dir mountPath : /etc/my-scripts defaultMode : 0744 # optional entries : - key : foo.sh value : |- #!/bin/sh echo \"Hello world from foo!\" - key : bar.sh value : |- #!/bin/sh echo \"Hello world from bar!\" ... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ... components : - name : comp-1 ... configs : - name : my-ca type : file mountPath : /etc/my-scripts defaultMode : 0744 # optional entries : - key : foo-script filename : foo.sh value : |- #!/bin/sh echo \"Hello world from foo!\" - key : bar-script filename : bar.sh value : |- #!/bin/sh echo \"Hello world from bar!\" ... CLI command mdos generate config From existing ConfigMap or Secret Mount as directory Mount as files 1 2 3 4 5 6 7 8 9 10 ... components : - name : comp-1 ... secrets : # or configs - name : my-ca type : dir mountPath : /etc/x509/https ref : my-root-domain-tls-secret # existing secret / configMap name to reference ... 1 2 3 4 5 6 7 8 9 10 11 12 13 ... components : - name : comp-1 ... secrets : # or configs - name : my-ca type : file mountPath : /etc/x509/https ref : my-root-domain-tls-secret # existing secret / configMap name to reference entries : - key : ca-crt # name of the configMap / secret key that contains the value filename : ca.crt # name of the file to use to mount this value as ... CLI command mdos generate secret or mdos generate config Environement Variables Using ConfigMaps or Secrets 1 2 3 4 5 6 7 8 9 10 11 12 13 ... components : - name : comp-1 ... secrets : # or configs - name : config-params type : env entries : - key : MY_VAR_1 value : \"my vlaue\" - key : MY_VAR_2 value : \"my other vlaue\" ... CLI command mdos generate secret or mdos generate config From existing ConfigMap or Secret 1 2 3 4 5 6 7 8 9 10 11 12 13 14 ... components : - name : comp-1 ... secrets : # or configs - name : rabbitmq-creds type : env ref : rabbitmq-cluster-default-user # existing secret / configMap name to reference entries : - name : RABBIT_PORT # variable name to set key : PORT # variable key name from the ref. secret / config - name : RABBIT_HOST key : HOST ... CLI command mdos generate secret or mdos generate config Networking Exposing ports using services 1 2 3 4 5 6 7 8 9 ... components : - name : comp-1 ... services : - name : http ports : - port : 80 ... CLI command mdos generate service Configure Ingress 1 2 3 4 5 6 7 8 9 10 ... components : - name : comp-1 ... ingress : - name : main matchHost : nginx.mydomain.com targetPort : 80 trafficType : http ... CLI command mdos generate ingress NetworkPolicy On a multi-tenant cluster environement, it is important that you protect your components from being accessed from other application components. There are 4 available configuration settings available for you to use: Scope Description private No one can talk to this component limited Only components belonging to this application can talk to this component open All application components in this tenant namespace can talk to this component custom You can specify which components in what namespaces can talk to this component This is how you configure this on your component: 1 2 3 4 5 6 7 ... components : - name : comp-1 ... networkPolicy : scope : private # limited | open | custom ... The custom scope let's you specify specifically what application components from what namespaces are allowed to communicate with this component. Here is a more complex example that uses a custom scoped NetworkPolicy (please note the addition of the allow array value in this case): OAuth2 OIDC Configure a OIDC provider Protect your ingress with a OIDC provider 1 2 3 4 5 6 7 8 9 ... components : - name : comp-1 ... oidc : provider : google-test-provider hosts : - nginx.mydomain.com ... CLI command mdos application protect Set pod resources 1 2 3 4 5 6 7 8 9 10 11 12 ... components : - name : comp-1 ... resources : requests : memory : \"64Mi\" cpu : \"250m\" limits : memory : \"128Mi\" cpu : \"500m\" ... Execute pre-build commands 1 2 3 4 5 6 7 8 9 ... components : - name : comp-1 ... preBuildCmd : - mkdocs build - rm -rf ../volumes/docs/* - cp -r ./site/* ../volumes/docs ...","title":"Reference Documentation"},{"location":"reference-documentation/#mdos-application-reference-documentation","text":"","title":"MDos application reference documentation"},{"location":"reference-documentation/#anatomy-of-an-application","text":"Applications are to be seen as a higher level concept, an application in mdos is composed of one or more application components. Application components are your actual project asset placeholders (source code), where one component could be an API backend server for instance, and a second component would hold your front end application and so on. Every application component can have one or more volumes attached to it for storage persistance & data mirroring. This architecture allows you to compose complex applications to suit your needs. A MDos application project layout is composed of one or more folders, each one representing an application component. At the root of the application folder is a mdos.yaml file that holds all runtime configuration parameters for the application and it's components: Project structure my-application/ \u251c\u2500\u2500 backend \u2502 \u2514\u2500\u2500 Dockerfile \u2502 \u2514\u2500\u2500 <your application code files>... \u251c\u2500\u2500 frontend \u2502 \u2514\u2500\u2500 Dockerfile \u2502 \u2514\u2500\u2500 <your application code files>... \u251c\u2500\u2500 volumes \u2502 \u2514\u2500\u2500 static-website \u2502 \u2514\u2500\u2500 index.html \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 mdos.yaml In this example we have an application named my-application , that is composed of two distinct application components: backend & frontend . Each component has it's own Dockerfile. At the application level, there is also a volumes folder where you can store application component volume files to be used within your application, and a mdos.yaml config file that holds all runtime configuration parameters. As an example, here the volumes folder has a subfolder called static-website that is used by the frontend application so serve it's website data. Note Volumes are managed on the application level rather than on the component level in case you wish to share volumes amongst components.","title":"Anatomy of an application"},{"location":"reference-documentation/#manifest-file-mdosyaml","text":"Each application is configured in a YAML file at the root of the application folder. This is the equivalent of your lower level Kubernetes yaml files, but all concatenated into a single, higher level configuration file that greatly abstracts away the complexity of Kubernetes deployment. We will now have a closer look at what you can configure in your application mdos.yaml file.","title":"Manifest file: mdos.yaml"},{"location":"reference-documentation/#application","text":"Each mdos.yaml file starts with global configuration parameters specific to this application: 1 2 3 4 5 schemaVersion : v1 tenantName : my-team appName : my-application uuid : XA74S-FXCDI components : [ ... ] The tenant-name field maps directly to a kubernetes target namespace . The uuid field is a unique identifier for this application, all dependant resources that this application will create and manage will be tied to this application uuid . CLI command mdos generate application","title":"Application"},{"location":"reference-documentation/#application-component","text":"Each application component will translate to a specific deployment on the cluster. Just like an application, a component hase some base values that need to be set: 1 2 3 4 5 6 7 8 9 10 11 12 ... components : - name : comp-1 image : my-comp-1-img-name tag : 1.0.0 uuid : E5PLU-TQMBD ... - name : comp-2 image : my-comp-2-img-name tag : 1.0.0 uuid : HUJKG-GDGHN ... Among those, you will define your component name , image name and image tag to use. CLI command mdos generate component When using the MDos CLI to scaffold your application component, then the CLI will ask you to select amonst multiple network isolation options. You can read more about NetworkPolicy isolation configurations in the section here","title":"Application component"},{"location":"reference-documentation/#registries","text":"Registries are where your MDos will push and pull your application images from. Multiple choices are available here.","title":" Registries"},{"location":"reference-documentation/#use-the-mdos-registry","text":"MDos comes with a private integrated Docker registry. If no registry parameter is set on your component yaml block, then this private internal registry will be used to push / pull the images from. No extra configuration parameters are required if this is the registry you want to use. 1 2 3 4 5 6 7 ... components : - name : comp-1 ... image : my-comp-1-img-name tag : 1.0.0 ...","title":" Use the MDos registry"},{"location":"reference-documentation/#use-a-custom-registry","text":"If you have your own private registry that you would like to use for your application images, you can do so by specifying a registry value on your component, along with an optionnal imagePullSecrets value that should be used to authenticate with your registry: 1 2 3 4 5 6 7 8 9 10 ... components : - name : comp-1 ... image : my-comp-1-img-name tag : 1.0.0 registry : my.private.registry imagePullSecrets : # Optionnal - name : my-registry-secret ... Note Since you are using your own private registry, it will be up to you to provision your private registry Secret on the target namespace.","title":" Use a custom registry"},{"location":"reference-documentation/#use-a-public-registry","text":"The third option is to use a public registry, again with an optionnal imagePullSecrets value that should be used to authenticate with the public registry: 1 2 3 4 5 6 7 8 9 components : - name : comp-1 ... image : my-comp-1-img-name tag : 1.0.0 publicRegistry : true imagePullSecrets : # Optionnal - name : my-registry-secret ...","title":" Use a public registry"},{"location":"reference-documentation/#overwrite-container-default-command-on-start","text":"If you wish to overwrite the command used by a container on startup, you can so so like this: 1 2 3 4 5 6 7 8 9 10 ... components : - name : comp-1 ... command : - \"sh\" - \"-c\" - \"mycommand\" workingDir : /from/this/dir # optional ... or along with command aguments: 1 2 3 4 5 6 7 8 ... components : - name : comp-1 ... command : [ \"printenv\" ] commandArgs : [ \"HOSTNAME\" , \"KUBERNETES_PORT\" ] workingDir : /from/this/dir # optional ...","title":" Overwrite container default command on start"},{"location":"reference-documentation/#persisted-volumes","text":"","title":" Persisted Volumes"},{"location":"reference-documentation/#standard-volumes","text":"1 2 3 4 5 6 7 8 9 ... components : - name : comp-1 ... volumes : - name : database-storage mountPath : /usr/data/db size : 10Gi ... CLI command mdos generate volume","title":" Standard volumes"},{"location":"reference-documentation/#shared-volumes","text":"mdos shared-volume create 1 2 3 4 5 6 7 8 9 ... components : - name : comp-1 ... volumes : - name : database-storage mountPath : /usr/data/db ref : my-shared-volume # existing secret / configMap name to reference ... CLI command mdos generate volume","title":" Shared volumes"},{"location":"reference-documentation/#pre-populate-volumes","text":"1 2 3 4 5 6 7 8 9 10 ... components : - name : comp-1 ... volumes : - name : static-website mountPath : /usr/share/nginx/html syncVolume : true size : 10Gi ... Project structure 1 2 3 4 5 6 ... \u251c\u2500\u2500 volumes \u2502 \u2514\u2500\u2500 static-website \u2502 \u2514\u2500\u2500 index.html \u2502 \u2514\u2500\u2500 ... \u2514\u2500\u2500 mdos.yaml CLI command mdos generate volume","title":" Pre-populate volumes"},{"location":"reference-documentation/#hostpath-mounts","text":"1 2 3 4 5 6 7 8 9 ... components : - name : comp-1 ... volumes : - name : database-storage mountPath : /usr/data/db hostPath : /path/to/folder/on/node ... CLI command mdos generate volume","title":" HostPath mounts"},{"location":"reference-documentation/#readonly-volumes-files","text":"","title":" ReadOnly volumes &amp; files"},{"location":"reference-documentation/#using-secrets","text":"Mount as directory Mount as files 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ... components : - name : comp-1 ... secrets : - name : my-ca type : dir mountPath : /etc/x509/https entries : - key : ca.crt value : |- -----BEGIN CERTIFICATE----- ... -----END CERTIFICATE----- - key : ca.key value : |- -----BEGIN EC PRIVATE KEY----- ... -----END EC PRIVATE KEY----- ... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ... components : - name : comp-1 ... secrets : - name : my-ca type : file mountPath : /etc/x509/https entries : - key : client-ca filename : ca.crt value : |- -----BEGIN CERTIFICATE----- ... -----END CERTIFICATE----- - key : client-key filename : ca.key value : |- -----BEGIN EC PRIVATE KEY----- ... -----END EC PRIVATE KEY----- ... CLI command mdos generate secret","title":" Using Secrets"},{"location":"reference-documentation/#using-configmaps","text":"Mount as directory Mount as files 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ... components : - name : comp-1 ... configs : - name : my-ca type : dir mountPath : /etc/my-scripts defaultMode : 0744 # optional entries : - key : foo.sh value : |- #!/bin/sh echo \"Hello world from foo!\" - key : bar.sh value : |- #!/bin/sh echo \"Hello world from bar!\" ... 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 ... components : - name : comp-1 ... configs : - name : my-ca type : file mountPath : /etc/my-scripts defaultMode : 0744 # optional entries : - key : foo-script filename : foo.sh value : |- #!/bin/sh echo \"Hello world from foo!\" - key : bar-script filename : bar.sh value : |- #!/bin/sh echo \"Hello world from bar!\" ... CLI command mdos generate config","title":" Using ConfigMaps"},{"location":"reference-documentation/#from-existing-configmap-or-secret","text":"Mount as directory Mount as files 1 2 3 4 5 6 7 8 9 10 ... components : - name : comp-1 ... secrets : # or configs - name : my-ca type : dir mountPath : /etc/x509/https ref : my-root-domain-tls-secret # existing secret / configMap name to reference ... 1 2 3 4 5 6 7 8 9 10 11 12 13 ... components : - name : comp-1 ... secrets : # or configs - name : my-ca type : file mountPath : /etc/x509/https ref : my-root-domain-tls-secret # existing secret / configMap name to reference entries : - key : ca-crt # name of the configMap / secret key that contains the value filename : ca.crt # name of the file to use to mount this value as ... CLI command mdos generate secret or mdos generate config","title":" From existing ConfigMap or Secret"},{"location":"reference-documentation/#environement-variables","text":"","title":" Environement Variables"},{"location":"reference-documentation/#using-configmaps-or-secrets","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 ... components : - name : comp-1 ... secrets : # or configs - name : config-params type : env entries : - key : MY_VAR_1 value : \"my vlaue\" - key : MY_VAR_2 value : \"my other vlaue\" ... CLI command mdos generate secret or mdos generate config","title":" Using ConfigMaps or Secrets"},{"location":"reference-documentation/#from-existing-configmap-or-secret_1","text":"1 2 3 4 5 6 7 8 9 10 11 12 13 14 ... components : - name : comp-1 ... secrets : # or configs - name : rabbitmq-creds type : env ref : rabbitmq-cluster-default-user # existing secret / configMap name to reference entries : - name : RABBIT_PORT # variable name to set key : PORT # variable key name from the ref. secret / config - name : RABBIT_HOST key : HOST ... CLI command mdos generate secret or mdos generate config","title":" From existing ConfigMap or Secret"},{"location":"reference-documentation/#networking","text":"","title":" Networking"},{"location":"reference-documentation/#exposing-ports-using-services","text":"1 2 3 4 5 6 7 8 9 ... components : - name : comp-1 ... services : - name : http ports : - port : 80 ... CLI command mdos generate service","title":" Exposing ports using services"},{"location":"reference-documentation/#configure-ingress","text":"1 2 3 4 5 6 7 8 9 10 ... components : - name : comp-1 ... ingress : - name : main matchHost : nginx.mydomain.com targetPort : 80 trafficType : http ... CLI command mdos generate ingress","title":" Configure Ingress"},{"location":"reference-documentation/#networkpolicy","text":"On a multi-tenant cluster environement, it is important that you protect your components from being accessed from other application components. There are 4 available configuration settings available for you to use: Scope Description private No one can talk to this component limited Only components belonging to this application can talk to this component open All application components in this tenant namespace can talk to this component custom You can specify which components in what namespaces can talk to this component This is how you configure this on your component: 1 2 3 4 5 6 7 ... components : - name : comp-1 ... networkPolicy : scope : private # limited | open | custom ... The custom scope let's you specify specifically what application components from what namespaces are allowed to communicate with this component. Here is a more complex example that uses a custom scoped NetworkPolicy (please note the addition of the allow array value in this case):","title":" NetworkPolicy"},{"location":"reference-documentation/#oauth2-oidc","text":"","title":" OAuth2 OIDC"},{"location":"reference-documentation/#configure-a-oidc-provider","text":"","title":" Configure a OIDC provider"},{"location":"reference-documentation/#protect-your-ingress-with-a-oidc-provider","text":"1 2 3 4 5 6 7 8 9 ... components : - name : comp-1 ... oidc : provider : google-test-provider hosts : - nginx.mydomain.com ... CLI command mdos application protect","title":" Protect your ingress with a OIDC provider"},{"location":"reference-documentation/#set-pod-resources","text":"1 2 3 4 5 6 7 8 9 10 11 12 ... components : - name : comp-1 ... resources : requests : memory : \"64Mi\" cpu : \"250m\" limits : memory : \"128Mi\" cpu : \"500m\" ...","title":" Set pod resources"},{"location":"reference-documentation/#execute-pre-build-commands","text":"1 2 3 4 5 6 7 8 9 ... components : - name : comp-1 ... preBuildCmd : - mkdocs build - rm -rf ../volumes/docs/* - cp -r ./site/* ../volumes/docs ...","title":" Execute pre-build commands"}]}