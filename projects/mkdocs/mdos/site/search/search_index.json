{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the MDos platform MDos is a application runtime platform based on Kubernetes to run your workloads on. Install the MDos CLI The easiest way to install the platform is to use the MDos CLI. Do do so, you will have to clone the repo on your target machine: git clone https://github.com/mdundek/mdundek.network.git Username: mdundek Password: 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 Then install the CLI by executing the following script: ./mdundek.network/cli/install/01_setup_mdos_cmd.sh During the installation of the CLI, you will be asked to enter your main domain name. Ex. mdundek.network Enter your root domain name: mdundek.network Once done, execute the following command to reload your aliases for the mdos CLI: source ~/.bashrc Set up the MDos platform To install the platform, you can use the mdos CLI to do so. For a more granual installation, the setup is split into multiple steps: Install and create your Cloudflare - Certbot SSL certificate & auto-renewal for your domain Install Code-server so that you can develop your applications using your favorite browser Install the K3S & Calico application runtime environement Install HELM for Kubernetes Install Istio for ingress Install a local NGinx server as a reverse proxy for your platform (also used to load-balance between nodes if you have more than one) Install a local private Docker regisytry on the K3S cluster Install Minio for file sharing The CLI command that will allow you to install each one of these components is mdos core-setup : You need to execute each one of those commands in the right order. Each component might ask for extra parameters to accomplish it's specific setup. 01 - Cloudflare & certbot SSL Select 01_certbot as the target installation step. You will be asked to enter your: Cloudflare email address Cloudflare API token Email: mdundek@gmail.com API token: fe5beef86732475a7073b122139f64f9f49ee Your SSL certificate is not setup and will automatically renew when necessary. Your crontab has also been updated to automatically update your public IP address on Cloudflare. Router config Make sure you configured your router to route ports 80 & 443 to this machine before moving forward with this script. Cloudflare DNS config Also make sure your domain is configured on CloudFlare: Cloudflare API config Create a CloudFlare API key as well, you will need it here ( My Profile -> API Token ): 02 - Code-server setup Select 02_codeserver as the target installation step. You will be asked to specify a code-server password. Once done, your code-server instance will be up and running, but you will have to wait untill you set up NGinx before being able to access it. Once that is done, you will be able to access your Code-server instance on the following URL: https://cs.<your domain> 03 - Code-server setup Select 03_k3s as the target installation step. You will be asked to enter your: The private docker registry username The private docker registry password Those will be used to set up your self signed registry certificate, along with your docker daemon and K3S containerd exceptions for the certificate. 04 - HELM setup Select 04_helm as the target installation step. This is straight forward, HELM is used to install applications on the mdos platform. 05 - Istio Ingress setup Select 05_istio as the target installation step. If you update the istio HELM yaml files, make sure to set the ingress-gateway nodeports to 30977 (status-port), 30978 (http2) & 30979 (https) in the yaml file files/istio_helm/gateways/istio-ingress/values.yaml 06 - NGinx reverse proxy setup Select 06_nginx as the target installation step. You will be asked to enter your: WAN facing username WAN facing password This NGinx server will capture traffic on port 443 and 80 on your machine, and forward this traffic to your local code-server, as well as to all applications running on your K3S cluster. Segregagtion happens on the HOST subdomain used with your CloudFlare main domain name. Unless configured otherwise, the NGinx server will also enforce user authentication for all application it serves NGinx is installed navively on the host, rather than as a container in the cluster. 07 - Private docker registry setup Select 07_registry as the target installation step. This registry is used by Kubernetes to store and distribute your private application images Extra disk mounts # Create mount folders mkdir /media/storage mkdir /media/multimedia mkdir /media/backup # Get partition UUIDs lsblk -o NAME,FSTYPE,UUID # Open fstab file vi /etc/fstab echo \"UUID=5dd2af09-b490-43bf-a688-e8c5f6a557ef /media/storage ext4 defaults 0 2\" >> /etc/fstab echo \"UUID=445d3106-669d-492e-b537-b444e9a666b2 /media/multimedia ext4 defaults 0 2\" >> /etc/fstab echo \"UUID=67643a4b-4bb9-45b2-9530-838bb48deb05 /media/backup ext4 defaults 0 2\" >> /etc/fstab mount -a","title":"Install"},{"location":"#welcome-to-the-mdos-platform","text":"MDos is a application runtime platform based on Kubernetes to run your workloads on.","title":"Welcome to the MDos platform"},{"location":"#install-the-mdos-cli","text":"The easiest way to install the platform is to use the MDos CLI. Do do so, you will have to clone the repo on your target machine: git clone https://github.com/mdundek/mdundek.network.git Username: mdundek Password: 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 Then install the CLI by executing the following script: ./mdundek.network/cli/install/01_setup_mdos_cmd.sh During the installation of the CLI, you will be asked to enter your main domain name. Ex. mdundek.network Enter your root domain name: mdundek.network Once done, execute the following command to reload your aliases for the mdos CLI: source ~/.bashrc","title":"Install the MDos CLI"},{"location":"#set-up-the-mdos-platform","text":"To install the platform, you can use the mdos CLI to do so. For a more granual installation, the setup is split into multiple steps: Install and create your Cloudflare - Certbot SSL certificate & auto-renewal for your domain Install Code-server so that you can develop your applications using your favorite browser Install the K3S & Calico application runtime environement Install HELM for Kubernetes Install Istio for ingress Install a local NGinx server as a reverse proxy for your platform (also used to load-balance between nodes if you have more than one) Install a local private Docker regisytry on the K3S cluster Install Minio for file sharing The CLI command that will allow you to install each one of these components is mdos core-setup : You need to execute each one of those commands in the right order. Each component might ask for extra parameters to accomplish it's specific setup.","title":"Set up the MDos platform"},{"location":"#01-cloudflare-certbot-ssl","text":"Select 01_certbot as the target installation step. You will be asked to enter your: Cloudflare email address Cloudflare API token Email: mdundek@gmail.com API token: fe5beef86732475a7073b122139f64f9f49ee Your SSL certificate is not setup and will automatically renew when necessary. Your crontab has also been updated to automatically update your public IP address on Cloudflare.","title":"01 - Cloudflare &amp; certbot SSL"},{"location":"#router-config","text":"Make sure you configured your router to route ports 80 & 443 to this machine before moving forward with this script.","title":"Router config"},{"location":"#cloudflare-dns-config","text":"Also make sure your domain is configured on CloudFlare:","title":"Cloudflare DNS config"},{"location":"#cloudflare-api-config","text":"Create a CloudFlare API key as well, you will need it here ( My Profile -> API Token ):","title":"Cloudflare API config"},{"location":"#02-code-server-setup","text":"Select 02_codeserver as the target installation step. You will be asked to specify a code-server password. Once done, your code-server instance will be up and running, but you will have to wait untill you set up NGinx before being able to access it. Once that is done, you will be able to access your Code-server instance on the following URL: https://cs.<your domain>","title":"02 - Code-server setup"},{"location":"#03-code-server-setup","text":"Select 03_k3s as the target installation step. You will be asked to enter your: The private docker registry username The private docker registry password Those will be used to set up your self signed registry certificate, along with your docker daemon and K3S containerd exceptions for the certificate.","title":"03 - Code-server setup"},{"location":"#04-helm-setup","text":"Select 04_helm as the target installation step. This is straight forward, HELM is used to install applications on the mdos platform.","title":"04 - HELM setup"},{"location":"#05-istio-ingress-setup","text":"Select 05_istio as the target installation step. If you update the istio HELM yaml files, make sure to set the ingress-gateway nodeports to 30977 (status-port), 30978 (http2) & 30979 (https) in the yaml file files/istio_helm/gateways/istio-ingress/values.yaml","title":"05 - Istio Ingress setup"},{"location":"#06-nginx-reverse-proxy-setup","text":"Select 06_nginx as the target installation step. You will be asked to enter your: WAN facing username WAN facing password This NGinx server will capture traffic on port 443 and 80 on your machine, and forward this traffic to your local code-server, as well as to all applications running on your K3S cluster. Segregagtion happens on the HOST subdomain used with your CloudFlare main domain name. Unless configured otherwise, the NGinx server will also enforce user authentication for all application it serves NGinx is installed navively on the host, rather than as a container in the cluster.","title":"06 - NGinx reverse proxy setup"},{"location":"#07-private-docker-registry-setup","text":"Select 07_registry as the target installation step. This registry is used by Kubernetes to store and distribute your private application images","title":"07 - Private docker registry setup"},{"location":"#extra","text":"","title":"Extra"},{"location":"#disk-mounts","text":"# Create mount folders mkdir /media/storage mkdir /media/multimedia mkdir /media/backup # Get partition UUIDs lsblk -o NAME,FSTYPE,UUID # Open fstab file vi /etc/fstab echo \"UUID=5dd2af09-b490-43bf-a688-e8c5f6a557ef /media/storage ext4 defaults 0 2\" >> /etc/fstab echo \"UUID=445d3106-669d-492e-b537-b444e9a666b2 /media/multimedia ext4 defaults 0 2\" >> /etc/fstab echo \"UUID=67643a4b-4bb9-45b2-9530-838bb48deb05 /media/backup ext4 defaults 0 2\" >> /etc/fstab mount -a","title":"disk mounts"},{"location":"getting-started/","text":"Getting started Anatomy of a mdos application Applications & application components Project layout my-application/ \u251c\u2500\u2500 backend \u2502 \u2514\u2500\u2500 Dockerfile \u251c\u2500\u2500 frontend \u2502 \u2514\u2500\u2500 Dockerfile \u2514\u2500\u2500 values.yaml In this example we have an application named my-application , that is composed of two distinct application components: backend & frontend . Each component has it's own Dockerfile. At the application level, there is also a values.yaml config file that holds all runtime configuration parameters for the application: mdosAcbmAppUUID: 8c259ee5-d70f-409b-8eea-3f410e385d0f mdosBundleName: my-ns appName: my-app appComponents: - name: backend mdosAcbmAppCompUUID: 552be6bf-4a8d-4003-aeb2-9999a535c299 replicaCount: 1 # Your image name and tag image: repository: backend tag: latest # Overwrite the default command for your docker image overwriteCommand: false command: [] commandArgs: [] # Services service: create: true type: ClusterIP portMappings: - port: 80 containerPort: 80 # Configure ingress for your application component virtualService: - gateway: http-gateway hosts: - backend.mdundek.network protocol: http httpMatch: prefix: / port: \"80\" svcPort: \"80\" # - gateway: http-gateway | https-gateway | <other> # hosts: # - chart-example.com # protocol: https # http / https / tls / tcp # tlsMatchHosts: # only for tls/https route # - host: chart-example.com # port: 443 # svcPort: 8443 # httpMatch: # only for http route # prefix: / # port: 80 # tcpMatchPorts: # only for tcp # - 27017 # svcPort: 80 # tls: [] # Configuration parameters config: enabled: false data: {} # data: # - type: file # will be mounted as a file inside the pod # key: test.config # value: \"Content of test.config file\" # mountPath: \"/etc/myApp/config/\" # - type: env # will be mounted as an ENV var inside the pod # key: TEST_ENV # value: \"Value of ENV variable TEST_ENV\" # Secret configuration parameters secrets: enabled: false data: {} # data: # - type: file # key: test.secret # value: \"Content of test.secret file\" # mountPath: \"/etc/myApp/config/\" # - type: env # key: SECRET_ENV # value: \"Value of ENV variable SECRET_ENV\" # Persist data to a persistent volume persistence: enabled: false # volumes: # - name: data-volume # size: 1Gi # mountPath: /tmp # ldlSync: false # sourcePath: /mdos/content-volumes/app1 # path from where data should be collected (ONLY used with ldlSync=true) # type: full # full / partial depending on the type of file copy (ONLY used with ldlSync=true) # hostpathVolumes: # - name: host-data-volume # mountPath: /tmp # hostPath: /mdos/content-volumes/app1 # type: Directory resources: {} # limits: # cpu: 100m # memory: 128Mi # requests: # cpu: 100m # memory: 128Mi - name: frontend mdosAcbmAppCompUUID: 5515dedf-9c1e-4afb-9f20-5238bfbd5256 replicaCount: 1 # Your image name and tag image: repository: frontend tag: latest # Overwrite the default command for your docker image overwriteCommand: false command: [] commandArgs: [] # Services service: create: true type: ClusterIP portMappings: - port: 80 containerPort: 80 # Configure ingress for your application component virtualService: - gateway: http-gateway hosts: - frontend.mdundek.network protocol: http httpMatch: prefix: / port: \"80\" svcPort: \"80\" # - gateway: http-gateway | https-gateway | <other> # hosts: # - chart-example.com # protocol: https # http / https / tls / tcp # tlsMatchHosts: # only for tls/https route # - host: chart-example.com # port: 443 # svcPort: 8443 # httpMatch: # only for http route # prefix: / # port: 80 # tcpMatchPorts: # only for tcp # - 27017 # svcPort: 80 # tls: [] # Configuration parameters config: enabled: false data: {} # data: # - type: file # will be mounted as a file inside the pod # key: test.config # value: \"Content of test.config file\" # mountPath: \"/etc/myApp/config/\" # - type: env # will be mounted as an ENV var inside the pod # key: TEST_ENV # value: \"Value of ENV variable TEST_ENV\" # Secret configuration parameters secrets: enabled: false data: {} # data: # - type: file # key: test.secret # value: \"Content of test.secret file\" # mountPath: \"/etc/myApp/config/\" # - type: env # key: SECRET_ENV # value: \"Value of ENV variable SECRET_ENV\" # Persist data to a persistent volume persistence: enabled: false # volumes: # - name: data-volume # size: 1Gi # mountPath: /tmp # ldlSync: false # sourcePath: /mdos/content-volumes/app1 # path from where data should be collected (ONLY used with ldlSync=true) # type: full # full / partial depending on the type of file copy (ONLY used with ldlSync=true) # hostpathVolumes: # - name: host-data-volume # mountPath: /tmp # hostPath: /mdos/content-volumes/app1 # type: Directory resources: {} # limits: # cpu: 100m # memory: 128Mi # requests: # cpu: 100m # memory: 128Mi Build applications for the platform Create a new application Create a new application component Deploy application on the platform Build your application Deploy your application","title":"Getting started"},{"location":"getting-started/#getting-started","text":"","title":"Getting started"},{"location":"getting-started/#anatomy-of-a-mdos-application","text":"","title":"Anatomy of a mdos application"},{"location":"getting-started/#applications-application-components","text":"","title":"Applications &amp; application components"},{"location":"getting-started/#project-layout","text":"my-application/ \u251c\u2500\u2500 backend \u2502 \u2514\u2500\u2500 Dockerfile \u251c\u2500\u2500 frontend \u2502 \u2514\u2500\u2500 Dockerfile \u2514\u2500\u2500 values.yaml In this example we have an application named my-application , that is composed of two distinct application components: backend & frontend . Each component has it's own Dockerfile. At the application level, there is also a values.yaml config file that holds all runtime configuration parameters for the application: mdosAcbmAppUUID: 8c259ee5-d70f-409b-8eea-3f410e385d0f mdosBundleName: my-ns appName: my-app appComponents: - name: backend mdosAcbmAppCompUUID: 552be6bf-4a8d-4003-aeb2-9999a535c299 replicaCount: 1 # Your image name and tag image: repository: backend tag: latest # Overwrite the default command for your docker image overwriteCommand: false command: [] commandArgs: [] # Services service: create: true type: ClusterIP portMappings: - port: 80 containerPort: 80 # Configure ingress for your application component virtualService: - gateway: http-gateway hosts: - backend.mdundek.network protocol: http httpMatch: prefix: / port: \"80\" svcPort: \"80\" # - gateway: http-gateway | https-gateway | <other> # hosts: # - chart-example.com # protocol: https # http / https / tls / tcp # tlsMatchHosts: # only for tls/https route # - host: chart-example.com # port: 443 # svcPort: 8443 # httpMatch: # only for http route # prefix: / # port: 80 # tcpMatchPorts: # only for tcp # - 27017 # svcPort: 80 # tls: [] # Configuration parameters config: enabled: false data: {} # data: # - type: file # will be mounted as a file inside the pod # key: test.config # value: \"Content of test.config file\" # mountPath: \"/etc/myApp/config/\" # - type: env # will be mounted as an ENV var inside the pod # key: TEST_ENV # value: \"Value of ENV variable TEST_ENV\" # Secret configuration parameters secrets: enabled: false data: {} # data: # - type: file # key: test.secret # value: \"Content of test.secret file\" # mountPath: \"/etc/myApp/config/\" # - type: env # key: SECRET_ENV # value: \"Value of ENV variable SECRET_ENV\" # Persist data to a persistent volume persistence: enabled: false # volumes: # - name: data-volume # size: 1Gi # mountPath: /tmp # ldlSync: false # sourcePath: /mdos/content-volumes/app1 # path from where data should be collected (ONLY used with ldlSync=true) # type: full # full / partial depending on the type of file copy (ONLY used with ldlSync=true) # hostpathVolumes: # - name: host-data-volume # mountPath: /tmp # hostPath: /mdos/content-volumes/app1 # type: Directory resources: {} # limits: # cpu: 100m # memory: 128Mi # requests: # cpu: 100m # memory: 128Mi - name: frontend mdosAcbmAppCompUUID: 5515dedf-9c1e-4afb-9f20-5238bfbd5256 replicaCount: 1 # Your image name and tag image: repository: frontend tag: latest # Overwrite the default command for your docker image overwriteCommand: false command: [] commandArgs: [] # Services service: create: true type: ClusterIP portMappings: - port: 80 containerPort: 80 # Configure ingress for your application component virtualService: - gateway: http-gateway hosts: - frontend.mdundek.network protocol: http httpMatch: prefix: / port: \"80\" svcPort: \"80\" # - gateway: http-gateway | https-gateway | <other> # hosts: # - chart-example.com # protocol: https # http / https / tls / tcp # tlsMatchHosts: # only for tls/https route # - host: chart-example.com # port: 443 # svcPort: 8443 # httpMatch: # only for http route # prefix: / # port: 80 # tcpMatchPorts: # only for tcp # - 27017 # svcPort: 80 # tls: [] # Configuration parameters config: enabled: false data: {} # data: # - type: file # will be mounted as a file inside the pod # key: test.config # value: \"Content of test.config file\" # mountPath: \"/etc/myApp/config/\" # - type: env # will be mounted as an ENV var inside the pod # key: TEST_ENV # value: \"Value of ENV variable TEST_ENV\" # Secret configuration parameters secrets: enabled: false data: {} # data: # - type: file # key: test.secret # value: \"Content of test.secret file\" # mountPath: \"/etc/myApp/config/\" # - type: env # key: SECRET_ENV # value: \"Value of ENV variable SECRET_ENV\" # Persist data to a persistent volume persistence: enabled: false # volumes: # - name: data-volume # size: 1Gi # mountPath: /tmp # ldlSync: false # sourcePath: /mdos/content-volumes/app1 # path from where data should be collected (ONLY used with ldlSync=true) # type: full # full / partial depending on the type of file copy (ONLY used with ldlSync=true) # hostpathVolumes: # - name: host-data-volume # mountPath: /tmp # hostPath: /mdos/content-volumes/app1 # type: Directory resources: {} # limits: # cpu: 100m # memory: 128Mi # requests: # cpu: 100m # memory: 128Mi","title":"Project layout"},{"location":"getting-started/#build-applications-for-the-platform","text":"","title":"Build applications for the platform"},{"location":"getting-started/#create-a-new-application","text":"","title":"Create a new application"},{"location":"getting-started/#create-a-new-application-component","text":"","title":"Create a new application component"},{"location":"getting-started/#deploy-application-on-the-platform","text":"","title":"Deploy application on the platform"},{"location":"getting-started/#build-your-application","text":"","title":"Build your application"},{"location":"getting-started/#deploy-your-application","text":"","title":"Deploy your application"},{"location":"minio/","text":"Minio S3 Use AWS CLI to work with Minio Configure client aws configure Values: AWS Access Key ID [****************W55N]: xxxx AWS Secret Access Key [****************Bjdu]: xxxx Default region name [None]: us-east-1 Default output format [None]: Set s3 API endpoint for minio: aws configure set default.s3.signature_version s3v4 Usage Create new bucket: aws --endpoint-url https://minio.mdundek.network s3 mb s3://mybucket List buckets: aws --endpoint-url https://minio.mdundek.network s3 ls Upload file to bucket: aws --endpoint-url https://minio.mdundek.network cp ./argparse-1.2.1.tar.gz s3://mybucket List bucket content: aws --endpoint-url https://minio.mdundek.network s3 ls s3://mybucket Remove item from bucket: aws --endpoint-url https://minio.mdundek.network rm s3://mybucket/argparse-1.2.1.tar.gz Delete bucket: aws --endpoint-url https://minio.mdundek.network s3 rb s3://mybucket Sync folder content with bucket: aws --endpoint-url https://minio.mdundek.network s3 sync . s3://mybucket/sync_folder/","title":"Minio S3"},{"location":"minio/#minio-s3","text":"","title":"Minio S3"},{"location":"minio/#use-aws-cli-to-work-with-minio","text":"","title":"Use AWS CLI to work with Minio"},{"location":"minio/#configure-client","text":"aws configure Values: AWS Access Key ID [****************W55N]: xxxx AWS Secret Access Key [****************Bjdu]: xxxx Default region name [None]: us-east-1 Default output format [None]: Set s3 API endpoint for minio: aws configure set default.s3.signature_version s3v4","title":"Configure client"},{"location":"minio/#usage","text":"","title":"Usage"},{"location":"minio/#create-new-bucket","text":"aws --endpoint-url https://minio.mdundek.network s3 mb s3://mybucket","title":"Create new bucket:"},{"location":"minio/#list-buckets","text":"aws --endpoint-url https://minio.mdundek.network s3 ls","title":"List buckets:"},{"location":"minio/#upload-file-to-bucket","text":"aws --endpoint-url https://minio.mdundek.network cp ./argparse-1.2.1.tar.gz s3://mybucket","title":"Upload file to bucket:"},{"location":"minio/#list-bucket-content","text":"aws --endpoint-url https://minio.mdundek.network s3 ls s3://mybucket","title":"List bucket content:"},{"location":"minio/#remove-item-from-bucket","text":"aws --endpoint-url https://minio.mdundek.network rm s3://mybucket/argparse-1.2.1.tar.gz","title":"Remove item from bucket:"},{"location":"minio/#delete-bucket","text":"aws --endpoint-url https://minio.mdundek.network s3 rb s3://mybucket","title":"Delete bucket:"},{"location":"minio/#sync-folder-content-with-bucket","text":"aws --endpoint-url https://minio.mdundek.network s3 sync . s3://mybucket/sync_folder/","title":"Sync folder content with bucket:"}]}